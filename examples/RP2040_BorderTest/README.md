# RP2040_BorderTest (ST77xxDMA + автояркость TEMT6000)

Этот пример демонстрирует работу библиотеки `ST77xxDMA` на платформах RP2040 (Raspberry Pi Pico и совместимые) c:

- зелёной рамкой по краю экрана и цветными вертикальными полосами внутри;
- поддержкой нескольких панелей ST77xx;
- автоматической регулировкой яркости подсветки по датчику освещённости **TEMT6000**.

## Аппаратная конфигурация

### Платы
- **MCU**: RP2040 (Pico/Zero и т.п.)
- **TFT**: панели на контроллерах ST7789 / ST7735S, поддерживаемые `ST77xxDMA`:
  - `ST7789_240x240`
  - `ST7789_135x240`
  - `ST7735_80x160`

### Пины SPI0 (по заданию пользователя)

Используются пины SPI0 RP2040:

- `PIN_MOSI = 7` — GPIO7 (SDA / MOSI)
- `PIN_MISO = -1` — не используется
- `PIN_SCLK = 6` — GPIO6 (SCL / SCLK)
- `PIN_CS   = 10` — GPIO10 (CS)
- `PIN_DC   = 9` — GPIO9  (D/C)
- `PIN_RST  = 8` — GPIO8  (RST)
- `PIN_BL   = 11` — GPIO11 (BL / подсветка, ШИМ)

### Датчик освещённости TEMT6000

Датчик TEMT6000 подключается к **ADC0**:

- Сигнальный вывод датчика → **GPIO26** (ADC0)
- Питание: 3.3V
- Земля: GND

В коде создаётся объект:

```cpp
static TEMT6000 g_lux(26, 3.3f, 4095); // GPIO26, 3.3В, 12-битный АЦП
```

## Выбор панели

В начале файла примера задаётся панель:

```cpp
static const ST77xxPanel PANEL = ST77xxPanel::ST7789_135x240; // или 240x240, или ST7735_80x160
```

Поддерживаются (и протестированы):

- `ST7789_240x240`
- `ST7789_135x240`
- `ST7735_80x160`

Для `ST7735_80x160` в библиотеке учтены:

- корректные RAM-оффсеты (окно не смещено);
- порядок цветов **BGR** (цвета отображаются правильно).

При необходимости можно изменить начальную ориентацию экрана:

```cpp
cfg.rotation = 0; // или 1, 2, 3
```

## Логика отрисовки

Функция `draw_border_and_bars()` рисует:

- чёрный фон по всему экрану (`fillScreen(Black)`);
- зелёную рамку по периметру (`drawRect(0, 0, w, h, Green)`);
- внутри рамки — 8 вертикальных цветных полос (White, Yellow, Cyan, Green, Magenta, Red, Blue, Black).

Это удобно для проверки:

- правильности оффсетов (рамка должна быть чётко по краю активной области);
- порядка цветов и инверсий.

## Автоматическая регулировка яркости (TEMT6000)

### Настройка АЦП

В `setup()` явно задаётся 12-битное разрешение АЦП:

```cpp
analogReadResolution(12); // диапазон 0..4095
```

### Алгоритм усреднения

В `loop()` каждые **100 мс** выполняются следующие действия:

1. Делаем **100 измерений** с АЦП на пине GPIO26:
   ```cpp
   uint32_t sum = 0;
   for (int i = 0; i < 100; ++i) {
     sum += analogRead(26);
   }
   uint16_t raw = (uint16_t)(sum / 100); // среднее 0..4095
   ```
2. Ограничиваем значение на всякий случай до 4095.
3. Преобразуем 12-битное значение (0..4095) в 8-битное (0..255):
   ```cpp
   uint8_t level = (uint8_t)(raw >> 4); // деление на 16
   ```
4. Выводим отладочную информацию в Serial:
   ```cpp
   Serial.print("raw=");  Serial.print(raw);
   Serial.print(" level="); Serial.println(level);
   ```
5. Передаём уровень яркости в библиотеку:
   ```cpp
   ST77xx::setBrightness(level);
   ```

### Почему так

- **100 измерений** и усреднение эффективно подавляют сетевое мерцание 50 Гц и шум.
- Интервал обновления **100 мс** не даёт яркости «дёргаться» при малых колебаниях света.
- Сдвиг `raw >> 4` даёт линейное соответствие между показаниями АЦП (0..4095) и ШИМ‑уровнем (0..255), который используется в `applyBacklight()` на RP2040.

## Использование

1. Подключите TFT по указанным пинам SPI0 RP2040.
2. Подключите TEMT6000 к GPIO26 (ADC0), 3.3V и GND.
3. В начале примера выберите нужную панель в `PANEL`.
4. Залейте скетч на плату.
5. В Serial Monitor наблюдайте строки вида:
   ```
   raw=4045 level=252
   ```
   и меняйте освещённость — экран будет автоматически менять яркость.

Этот пример можно переносить и в основной репозиторий (в раздел examples), README останется рядом с `.ino` и будет описывать особенности именно этого теста.
